diff -rupN a/drivers/acpi/scan.c b/drivers/acpi/scan.c
--- a/drivers/acpi/scan.c	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/acpi/scan.c	2026-01-07 11:33:17.870340532 +0100
@@ -2205,6 +2205,9 @@ static acpi_status acpi_bus_check_add_2(
 
 static void acpi_default_enumeration(struct acpi_device *device)
 {
+	if (!acpi_dev_ready_for_enumeration(device))
+		return;
+
 	/*
 	 * Do not enumerate devices with enumeration_by_parent flag set as
 	 * they will be enumerated by their respective parents.
diff -rupN a/drivers/iommu/intel/iommu.c b/drivers/iommu/intel/iommu.c
--- a/drivers/iommu/intel/iommu.c	2026-01-07 10:36:06.901244018 +0100
+++ b/drivers/iommu/intel/iommu.c	2026-01-07 11:33:17.871573881 +0100
@@ -44,6 +44,13 @@
 		((pdev)->vendor == PCI_VENDOR_ID_INTEL && (pdev)->device == 0x34E4) \
 	)
 
+#define IS_INTEL_IPU(pdev) ((pdev)->vendor == PCI_VENDOR_ID_INTEL &&	\
+			   ((pdev)->device == 0x9a19 ||		\
+			    (pdev)->device == 0x9a39 ||		\
+			    (pdev)->device == 0x4e19 ||		\
+			    (pdev)->device == 0x465d ||		\
+			    (pdev)->device == 0x1919))
+
 #define IOAPIC_RANGE_START	(0xfee00000)
 #define IOAPIC_RANGE_END	(0xfeefffff)
 #define IOVA_START_ADDR		(0x1000)
@@ -208,12 +215,14 @@ int intel_iommu_enabled = 0;
 EXPORT_SYMBOL_GPL(intel_iommu_enabled);
 
 static int dmar_map_ipts = 1;
+static int dmar_map_ipu = 1;
 static int intel_iommu_superpage = 1;
 static int iommu_identity_mapping;
 static int iommu_skip_te_disable;
 static int disable_igfx_iommu;
 
 #define IDENTMAP_AZALIA		4
+#define IDENTMAP_IPU		8
 #define IDENTMAP_IPTS		16
 
 const struct iommu_ops intel_iommu_ops;
@@ -1409,6 +1418,9 @@ static int device_def_domain_type(struct
 		if ((iommu_identity_mapping & IDENTMAP_AZALIA) && IS_AZALIA(pdev))
 			return IOMMU_DOMAIN_IDENTITY;
 
+		if ((iommu_identity_mapping & IDENTMAP_IPU) && IS_INTEL_IPU(pdev))
+			return IOMMU_DOMAIN_IDENTITY;
+
 		if ((iommu_identity_mapping & IDENTMAP_IPTS) && IS_IPTS(pdev))
 			return IOMMU_DOMAIN_IDENTITY;
 	}
@@ -1701,6 +1713,9 @@ static int __init init_dmars(void)
 		iommu_set_root_entry(iommu);
 	}
 
+	if (!dmar_map_ipu)
+		iommu_identity_mapping |= IDENTMAP_IPU;
+
 	if (!dmar_map_ipts)
 		iommu_identity_mapping |= IDENTMAP_IPTS;
 
@@ -3949,6 +3964,18 @@ static void quirk_iommu_igfx(struct pci_
 	disable_igfx_iommu = 1;
 }
 
+static void quirk_iommu_ipu(struct pci_dev *dev)
+{
+	if (!IS_INTEL_IPU(dev))
+		return;
+
+	if (risky_device(dev))
+		return;
+
+	pci_info(dev, "Passthrough IOMMU for integrated Intel IPU\n");
+	dmar_map_ipu = 0;
+}
+
 static void quirk_iommu_ipts(struct pci_dev *dev)
 {
 	if (!IS_IPTS(dev))
@@ -3999,6 +4026,9 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x163A, quirk_iommu_igfx);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x163D, quirk_iommu_igfx);
 
+/* disable IPU dmar support */
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_ANY_ID, quirk_iommu_ipu);
+
 /* disable IPTS dmar support */
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9D3E, quirk_iommu_ipts);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x34E4, quirk_iommu_ipts);
diff -rupN a/drivers/leds/Kconfig b/drivers/leds/Kconfig
--- a/drivers/leds/Kconfig	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/leds/Kconfig	2026-01-07 11:33:17.876922234 +0100
@@ -998,6 +998,18 @@ config LEDS_TPS6105X
 	  It is a single boost converter primarily for white LEDs and
 	  audio amplifiers.
 
+config LEDS_TPS68470
+	tristate "LED support for TI TPS68470"
+	depends on LEDS_CLASS
+	depends on INTEL_SKL_INT3472
+	help
+	  This driver supports TPS68470 PMIC with LED chip.
+	  It provides two LED controllers, with the ability to drive 2
+	  indicator LEDs and 2 flash LEDs.
+
+	  To compile this driver as a module, choose M and it will be
+	  called leds-tps68470
+
 config LEDS_IP30
 	tristate "LED support for SGI Octane machines"
 	depends on LEDS_CLASS
diff -rupN a/drivers/leds/leds-tps68470.c b/drivers/leds/leds-tps68470.c
--- a/drivers/leds/leds-tps68470.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/leds/leds-tps68470.c	2026-01-07 11:33:17.877509458 +0100
@@ -0,0 +1,185 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * LED driver for TPS68470 PMIC
+ *
+ * Copyright (C) 2023 Red Hat
+ *
+ * Authors:
+ *	Kate Hsuan <hpa@redhat.com>
+ */
+
+#include <linux/leds.h>
+#include <linux/mfd/tps68470.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+
+
+#define lcdev_to_led(led_cdev) \
+	container_of(led_cdev, struct tps68470_led, lcdev)
+
+#define led_to_tps68470(led, index) \
+	container_of(led, struct tps68470_device, leds[index])
+
+enum tps68470_led_ids {
+	TPS68470_ILED_A,
+	TPS68470_ILED_B,
+	TPS68470_NUM_LEDS
+};
+
+static const char *tps68470_led_names[] = {
+	[TPS68470_ILED_A] = "tps68470-iled_a",
+	[TPS68470_ILED_B] = "tps68470-iled_b",
+};
+
+struct tps68470_led {
+	unsigned int led_id;
+	struct led_classdev lcdev;
+};
+
+struct tps68470_device {
+	struct device *dev;
+	struct regmap *regmap;
+	struct tps68470_led leds[TPS68470_NUM_LEDS];
+};
+
+enum ctrlb_current {
+	CTRLB_2MA	= 0,
+	CTRLB_4MA	= 1,
+	CTRLB_8MA	= 2,
+	CTRLB_16MA	= 3,
+};
+
+static int tps68470_brightness_set(struct led_classdev *led_cdev, enum led_brightness brightness)
+{
+	struct tps68470_led *led = lcdev_to_led(led_cdev);
+	struct tps68470_device *tps68470 = led_to_tps68470(led, led->led_id);
+	struct regmap *regmap = tps68470->regmap;
+
+	switch (led->led_id) {
+	case TPS68470_ILED_A:
+		return regmap_update_bits(regmap, TPS68470_REG_ILEDCTL, TPS68470_ILEDCTL_ENA,
+					  brightness ? TPS68470_ILEDCTL_ENA : 0);
+	case TPS68470_ILED_B:
+		return regmap_update_bits(regmap, TPS68470_REG_ILEDCTL, TPS68470_ILEDCTL_ENB,
+					  brightness ? TPS68470_ILEDCTL_ENB : 0);
+	}
+	return -EINVAL;
+}
+
+static enum led_brightness tps68470_brightness_get(struct led_classdev *led_cdev)
+{
+	struct tps68470_led *led = lcdev_to_led(led_cdev);
+	struct tps68470_device *tps68470 = led_to_tps68470(led, led->led_id);
+	struct regmap *regmap = tps68470->regmap;
+	int ret = 0;
+	int value = 0;
+
+	ret =  regmap_read(regmap, TPS68470_REG_ILEDCTL, &value);
+	if (ret)
+		return dev_err_probe(led_cdev->dev, -EINVAL, "failed on reading register\n");
+
+	switch (led->led_id) {
+	case TPS68470_ILED_A:
+		value = value & TPS68470_ILEDCTL_ENA;
+		break;
+	case TPS68470_ILED_B:
+		value = value & TPS68470_ILEDCTL_ENB;
+		break;
+	}
+
+	return value ? LED_ON : LED_OFF;
+}
+
+
+static int tps68470_ledb_current_init(struct platform_device *pdev,
+				      struct tps68470_device *tps68470)
+{
+	int ret = 0;
+	unsigned int curr;
+
+	/* configure LEDB current if the properties can be got */
+	if (!device_property_read_u32(&pdev->dev, "ti,ledb-current", &curr)) {
+		if (curr > CTRLB_16MA) {
+			dev_err(&pdev->dev,
+				"Invalid LEDB current value: %d\n",
+				curr);
+			return -EINVAL;
+		}
+		ret = regmap_update_bits(tps68470->regmap, TPS68470_REG_ILEDCTL,
+					 TPS68470_ILEDCTL_CTRLB, curr);
+	}
+	return ret;
+}
+
+static int tps68470_leds_probe(struct platform_device *pdev)
+{
+	int i = 0;
+	int ret = 0;
+	struct tps68470_device *tps68470;
+	struct tps68470_led *led;
+	struct led_classdev *lcdev;
+
+	tps68470 = devm_kzalloc(&pdev->dev, sizeof(struct tps68470_device),
+				GFP_KERNEL);
+	if (!tps68470)
+		return -ENOMEM;
+
+	tps68470->dev = &pdev->dev;
+	tps68470->regmap = dev_get_drvdata(pdev->dev.parent);
+
+	for (i = 0; i < TPS68470_NUM_LEDS; i++) {
+		led = &tps68470->leds[i];
+		lcdev = &led->lcdev;
+
+		led->led_id = i;
+
+		lcdev->name = devm_kasprintf(tps68470->dev, GFP_KERNEL, "%s::%s",
+					     tps68470_led_names[i], LED_FUNCTION_INDICATOR);
+		if (!lcdev->name)
+			return -ENOMEM;
+
+		lcdev->max_brightness = 1;
+		lcdev->brightness = 0;
+		lcdev->brightness_set_blocking = tps68470_brightness_set;
+		lcdev->brightness_get = tps68470_brightness_get;
+		lcdev->dev = &pdev->dev;
+
+		ret = devm_led_classdev_register(tps68470->dev, lcdev);
+		if (ret) {
+			dev_err_probe(tps68470->dev, ret,
+				      "error registering led\n");
+			goto err_exit;
+		}
+
+		if (i == TPS68470_ILED_B) {
+			ret = tps68470_ledb_current_init(pdev, tps68470);
+			if (ret)
+				goto err_exit;
+		}
+	}
+
+err_exit:
+	if (ret) {
+		for (i = 0; i < TPS68470_NUM_LEDS; i++) {
+			if (tps68470->leds[i].lcdev.name)
+				devm_led_classdev_unregister(&pdev->dev,
+							     &tps68470->leds[i].lcdev);
+		}
+	}
+
+	return ret;
+}
+static struct platform_driver tps68470_led_driver = {
+	.driver = {
+		   .name = "tps68470-led",
+	},
+	.probe = tps68470_leds_probe,
+};
+
+module_platform_driver(tps68470_led_driver);
+
+MODULE_ALIAS("platform:tps68470-led");
+MODULE_DESCRIPTION("LED driver for TPS68470 PMIC");
+MODULE_LICENSE("GPL v2");
diff -rupN a/drivers/leds/Makefile b/drivers/leds/Makefile
--- a/drivers/leds/Makefile	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/leds/Makefile	2026-01-07 11:33:17.877247511 +0100
@@ -93,6 +93,7 @@ obj-$(CONFIG_LEDS_TCA6507)		+= leds-tca6
 obj-$(CONFIG_LEDS_TI_LMU_COMMON)	+= leds-ti-lmu-common.o
 obj-$(CONFIG_LEDS_TLC591XX)		+= leds-tlc591xx.o
 obj-$(CONFIG_LEDS_TPS6105X)		+= leds-tps6105x.o
+obj-$(CONFIG_LEDS_TPS68470)		+= leds-tps68470.o
 obj-$(CONFIG_LEDS_TURRIS_OMNIA)		+= leds-turris-omnia.o
 obj-$(CONFIG_LEDS_UPBOARD)		+= leds-upboard.o
 obj-$(CONFIG_LEDS_WM831X_STATUS)	+= leds-wm831x-status.o
diff -rupN a/drivers/media/i2c/dw9719.c b/drivers/media/i2c/dw9719.c
--- a/drivers/media/i2c/dw9719.c	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/media/i2c/dw9719.c	2026-01-07 11:38:45.026924288 +0100
@@ -121,6 +121,9 @@ static int dw9719_power_up(struct dw9719
 	if (ret)
 		return ret;
 
+	/* Wait for device to be acknowledged */
+	fsleep(10000);
+
 	/*
 	 * Need 100us to transition from SHUTDOWN to STANDBY.
 	 * Jiggle the SCL pin to wake up the device (even when the regulator is
diff -rupN a/drivers/media/i2c/ov13858.c b/drivers/media/i2c/ov13858.c
--- a/drivers/media/i2c/ov13858.c	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/media/i2c/ov13858.c	2026-01-07 11:33:17.878667037 +0100
@@ -2,6 +2,7 @@
 // Copyright (c) 2017 Intel Corporation.
 
 #include <linux/acpi.h>
+#include <linux/delay.h>
 #include <linux/clk.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
@@ -119,6 +120,14 @@ struct ov13858_mode {
 	struct ov13858_reg_list reg_list;
 };
 
+// Or use standard names that might be more correct:
+static const char * const ov13858_supply_names[] = {
+	"avdd",    // Analog voltage
+	"pwr1",    // Digital core voltage
+};
+
+#define OV13858_NUM_SUPPLIES ARRAY_SIZE(ov13858_supply_names)
+
 /* 4224x3136 needs 1080Mbps/lane, 4 lanes */
 static const struct ov13858_reg mipi_data_rate_1080mbps[] = {
 	/* PLL1 registers */
@@ -1046,12 +1055,126 @@ struct ov13858 {
 	/* Current mode */
 	const struct ov13858_mode *cur_mode;
 
+	struct regulator_bulk_data supplies[OV13858_NUM_SUPPLIES];
+	struct gpio_desc *reset;
+	struct clk *xvclk;
+
 	/* Mutex for serialized access */
 	struct mutex mutex;
 };
 
 #define to_ov13858(_sd)	container_of(_sd, struct ov13858, sd)
 
+
+static int ov13858_get_regulators(struct ov13858 *ov13858)
+{
+	unsigned int i;
+
+	for (i = 0; i < OV13858_NUM_SUPPLIES; i++)
+		ov13858->supplies[i].supply = ov13858_supply_names[i];
+
+	return devm_regulator_bulk_get(ov13858->dev, OV13858_NUM_SUPPLIES,
+				       ov13858->supplies);
+}
+
+static int ov13858_sensor_powerup(struct ov13858 *ov13858)
+{
+	int ret;
+
+	dev_info(ov13858->dev, "Powering up sensor\n");
+
+	/* Assert reset */
+	gpiod_set_value_cansleep(ov13858->reset, 1);
+
+	/* Enable clock FIRST - sensor needs clock to communicate */
+	ret = clk_prepare_enable(ov13858->xvclk);
+	if (ret) {
+		dev_err(ov13858->dev, "Failed to enable clock: %d\n", ret);
+		return ret;
+	}
+	dev_info(ov13858->dev, "Clock enabled\n");
+
+	/* Enable regulators */
+	ret = regulator_bulk_enable(OV13858_NUM_SUPPLIES, ov13858->supplies);
+	if (ret) {
+		dev_err(ov13858->dev, "Failed to enable regulators: %d\n", ret);
+		clk_disable_unprepare(ov13858->xvclk);
+		return ret;
+	}
+
+	dev_info(ov13858->dev, "Regulators enabled\n");
+
+	/* Wait for power to stabilize */
+	usleep_range(5000, 10000);
+
+	/* De-assert reset */
+	gpiod_set_value_cansleep(ov13858->reset, 0);
+
+	/* Wait for sensor to boot */
+	msleep(20);
+
+	dev_info(ov13858->dev, "Reset de-asserted, sensor should be ready\n");
+
+	return 0;
+}
+
+static void ov13858_sensor_powerdown(struct ov13858 *ov13858)
+{
+	dev_info(ov13858->dev, "Powering down sensor\n");
+
+	/* Assert reset to put sensor in reset state */
+	gpiod_set_value_cansleep(ov13858->reset, 1);
+
+	/* Disable regulators */
+	regulator_bulk_disable(OV13858_NUM_SUPPLIES, ov13858->supplies);
+	dev_info(ov13858->dev, "Regulators disabled\n");
+
+	/* Disable clock */
+	clk_disable_unprepare(ov13858->xvclk);
+	dev_info(ov13858->dev, "Clock disabled\n");
+}
+
+static int __maybe_unused ov13858_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13858 *ov13858 = to_ov13858(sd);
+
+	ov13858_sensor_powerdown(ov13858);
+
+	return 0;
+}
+
+static int __maybe_unused ov13858_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	int ret;
+
+	ret = ov13858_sensor_powerup(ov13858);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static const struct dev_pm_ops ov13858_pm_ops = {
+	SET_RUNTIME_PM_OPS(ov13858_suspend, ov13858_resume, NULL)
+};
+
+static int ov13858_get_gpios(struct ov13858 *ov13858)
+{
+	ov13858->reset = devm_gpiod_get_optional(ov13858->dev, "reset",
+	                                         GPIOD_OUT_HIGH);
+	if (IS_ERR(ov13858->reset)) {
+		dev_err(ov13858->dev, "Error fetching reset GPIO\n");
+		return PTR_ERR(ov13858->reset);
+	}
+
+	return 0;
+}
+
 /* Read registers up to 4 at a time */
 static int ov13858_read_reg(struct ov13858 *ov13858, u16 reg, u32 len,
 			    u32 *val)
@@ -1498,8 +1621,11 @@ static int ov13858_identify_module(struc
 	int ret;
 	u32 val;
 
+	dev_info(ov13858->dev, "Attempting to read chip ID from register 0x300a\n");
 	ret = ov13858_read_reg(ov13858, OV13858_REG_CHIP_ID,
 			       OV13858_REG_VALUE_24BIT, &val);
+	dev_info(ov13858->dev, "Chip ID read result: ret=%d, val=0x%06x (expected 0x%06x)\n",
+	         ret, val, OV13858_CHIP_ID);
 	if (ret)
 		return ret;
 
@@ -1509,6 +1635,7 @@ static int ov13858_identify_module(struc
 		return -EIO;
 	}
 
+	dev_info(ov13858->dev, "Chip ID verified successfully!\n");
 	return 0;
 }
 
@@ -1678,14 +1805,33 @@ static int ov13858_probe(struct i2c_clie
 				     "external clock %lu is not supported\n",
 				     freq);
 
+	/* Get the external clock */
+	ov13858->xvclk = devm_clk_get_optional(ov13858->dev, "xvclk");
+	if (IS_ERR(ov13858->xvclk))
+		return dev_err_probe(ov13858->dev, PTR_ERR(ov13858->xvclk),
+		       "failed to get xvclk\n");
+
 	/* Initialize subdev */
 	v4l2_i2c_subdev_init(&ov13858->sd, client, &ov13858_subdev_ops);
 
+	ret = ov13858_get_regulators(ov13858);
+	if (ret)
+		return dev_err_probe(ov13858->dev, ret,
+		       "Error fetching regulators\n");
+
+	ret = ov13858_get_gpios(ov13858);
+	if (ret)
+		return ret;
+
+	ret = ov13858_sensor_powerup(ov13858);
+	if (ret)
+		return ret;  // No cleanup needed yet, devm handles GPIOs/regulators
+
 	/* Check module identity */
 	ret = ov13858_identify_module(ov13858);
 	if (ret) {
 		dev_err(ov13858->dev, "failed to find sensor: %d\n", ret);
-		return ret;
+		goto error_power_off;  // Now we need to power down
 	}
 
 	/* Set default mode to max resolution */
@@ -1693,7 +1839,7 @@ static int ov13858_probe(struct i2c_clie
 
 	ret = ov13858_init_controls(ov13858);
 	if (ret)
-		return ret;
+		goto error_power_off;
 
 	/* Initialize subdev */
 	ov13858->sd.internal_ops = &ov13858_internal_ops;
@@ -1729,6 +1875,10 @@ error_media_entity:
 
 error_handler_free:
 	ov13858_free_controls(ov13858);
+
+error_power_off:
+	ov13858_sensor_powerdown(ov13858);
+
 	dev_err(ov13858->dev, "%s failed:%d\n", __func__, ret);
 
 	return ret;
@@ -1744,6 +1894,9 @@ static void ov13858_remove(struct i2c_cl
 	ov13858_free_controls(ov13858);
 
 	pm_runtime_disable(ov13858->dev);
+	if (!pm_runtime_status_suspended(ov13858->dev))
+		ov13858_sensor_powerdown(ov13858);
+	pm_runtime_set_suspended(ov13858->dev);
 }
 
 static const struct i2c_device_id ov13858_id_table[] = {
@@ -1765,6 +1918,7 @@ MODULE_DEVICE_TABLE(acpi, ov13858_acpi_i
 static struct i2c_driver ov13858_i2c_driver = {
 	.driver = {
 		.name = "ov13858",
+		.pm = &ov13858_pm_ops,
 		.acpi_match_table = ACPI_PTR(ov13858_acpi_ids),
 	},
 	.probe = ov13858_probe,
diff -rupN a/drivers/media/i2c/ov5693.c b/drivers/media/i2c/ov5693.c
--- a/drivers/media/i2c/ov5693.c	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/media/i2c/ov5693.c	2026-01-07 11:33:17.879341641 +0100
@@ -1396,6 +1396,7 @@ static const struct dev_pm_ops ov5693_pm
 
 static const struct acpi_device_id ov5693_acpi_match[] = {
 	{"INT33BE"},
+	{"OVTI5693"},
 	{},
 };
 MODULE_DEVICE_TABLE(acpi, ov5693_acpi_match);
diff -rupN a/drivers/media/i2c/ov7251.c b/drivers/media/i2c/ov7251.c
--- a/drivers/media/i2c/ov7251.c	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/media/i2c/ov7251.c	2026-01-07 11:33:17.873108317 +0100
@@ -1053,7 +1053,7 @@ static int ov7251_s_ctrl(struct v4l2_ctr
 	case V4L2_CID_EXPOSURE:
 		ret = ov7251_set_exposure(ov7251, ctrl->val);
 		break;
-	case V4L2_CID_GAIN:
+	case V4L2_CID_ANALOGUE_GAIN:
 		ret = ov7251_set_gain(ov7251, ctrl->val);
 		break;
 	case V4L2_CID_TEST_PATTERN:
@@ -1579,7 +1579,7 @@ static int ov7251_init_ctrls(struct ov72
 	ov7251->exposure = v4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,
 					     V4L2_CID_EXPOSURE, 1, 32, 1, 32);
 	ov7251->gain = v4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,
-					 V4L2_CID_GAIN, 16, 1023, 1, 16);
+					 V4L2_CID_ANALOGUE_GAIN, 16, 1023, 1, 16);
 	v4l2_ctrl_new_std_menu_items(&ov7251->ctrls, &ov7251_ctrl_ops,
 				     V4L2_CID_TEST_PATTERN,
 				     ARRAY_SIZE(ov7251_test_pattern_menu) - 1,
diff -rupN a/drivers/media/pci/intel/ipu-bridge.c b/drivers/media/pci/intel/ipu-bridge.c
--- a/drivers/media/pci/intel/ipu-bridge.c	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/media/pci/intel/ipu-bridge.c	2026-01-07 11:33:17.879819255 +0100
@@ -60,6 +60,10 @@ static const struct ipu_sensor_config ip
 	IPU_SENSOR_CONFIG("INT33BE", 1, 419200000),
 	/* Onsemi MT9M114 */
 	IPU_SENSOR_CONFIG("INT33F0", 1, 384000000),
+	/* Omnivision OV5693 - Surface Pro 9 */
+	IPU_SENSOR_CONFIG("OVTI5693", 1, 419200000),
+	/* Omnivision OV13858 - Surface Pro 9 */
+	IPU_SENSOR_CONFIG("OVTID858", 4, 540000000),
 	/* Omnivision OV2740 */
 	IPU_SENSOR_CONFIG("INT3474", 1, 180000000),
 	/* Omnivision OV5670 */
diff -rupN a/drivers/media/v4l2-core/v4l2-async.c b/drivers/media/v4l2-core/v4l2-async.c
--- a/drivers/media/v4l2-core/v4l2-async.c	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/media/v4l2-core/v4l2-async.c	2026-01-07 11:33:17.873673274 +0100
@@ -799,6 +799,10 @@ int __v4l2_async_register_subdev(struct
 
 	INIT_LIST_HEAD(&sd->asc_list);
 
+	ret = v4l2_subdev_get_privacy_led(sd);
+	if (ret < 0)
+		return ret;
+
 	/*
 	 * No reference taken. The reference is held by the device (struct
 	 * v4l2_subdev.dev), and async sub-device does not exist independently
diff -rupN a/drivers/media/v4l2-core/v4l2-fwnode.c b/drivers/media/v4l2-core/v4l2-fwnode.c
--- a/drivers/media/v4l2-core/v4l2-fwnode.c	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/media/v4l2-core/v4l2-fwnode.c	2026-01-07 11:33:17.874097335 +0100
@@ -1260,10 +1260,6 @@ int v4l2_async_register_subdev_sensor(st
 
 	v4l2_async_subdev_nf_init(notifier, sd);
 
-	ret = v4l2_subdev_get_privacy_led(sd);
-	if (ret < 0)
-		goto out_cleanup;
-
 	ret = v4l2_async_nf_parse_fwnode_sensor(sd->dev, notifier);
 	if (ret < 0)
 		goto out_cleanup;
diff -rupN a/drivers/platform/x86/intel/int3472/discrete.c b/drivers/platform/x86/intel/int3472/discrete.c
--- a/drivers/platform/x86/intel/int3472/discrete.c	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/platform/x86/intel/int3472/discrete.c	2026-01-07 11:33:17.880151642 +0100
@@ -229,6 +229,14 @@ static void int3472_get_con_id_and_polar
 		/* Setups using a handshake pin need 25 ms enable delay */
 		*enable_time_us = 25 * USEC_PER_MSEC;
 		break;
+	case 0x08:  /* Surface Pro 9 - additional power rail */
+		*con_id = "pwr1";
+		*gpio_flags = GPIO_ACTIVE_HIGH;
+		break;
+	case 0x10:  /* Surface Pro 9 - secondary power rail */
+		*con_id = "pwr2";
+		*gpio_flags = GPIO_ACTIVE_HIGH;
+		break;
 	default:
 		*con_id = "unknown";
 		*gpio_flags = GPIO_ACTIVE_HIGH;
@@ -333,6 +341,8 @@ static int skl_int3472_handle_gpio_resou
 	case INT3472_GPIO_TYPE_PRIVACY_LED:
 	case INT3472_GPIO_TYPE_POWER_ENABLE:
 	case INT3472_GPIO_TYPE_HANDSHAKE:
+	case 0x08:  /* Surface Pro 9 power rails */
+	case 0x10:
 		gpio = skl_int3472_gpiod_get_from_temp_lookup(int3472, agpio, con_id, gpio_flags);
 		if (IS_ERR(gpio)) {
 			ret = PTR_ERR(gpio);
@@ -363,6 +373,19 @@ static int skl_int3472_handle_gpio_resou
 				err_msg = "Failed to register regulator\n";
 
 			break;
+		case 0x08:  /* Surface Pro 9 - treat as power*/
+		    dev_info(int3472->dev, "GPIO type 0x%02x detected on pin 0x%02x\n", type, agpio->pin_table[0]);
+		    dev_info(int3472->dev, "  con_id=%s, flags=0x%x\n", con_id, gpio_flags);
+		    ret = skl_int3472_register_regulator(int3472, gpio,
+			 GPIO_REGULATOR_ENABLE_TIME,
+			 con_id, NULL);
+		    dev_info(int3472->dev, "  register_regulator returned: %d\n", ret);
+		    if (ret) {
+			dev_err(int3472->dev, "Failed to register type 0x02x: %d\n", type, ret);
+		    }
+		    break;
+		case 0x10:
+		    break;
 		default: /* Never reached */
 			ret = -EINVAL;
 			break;
diff -rupN a/drivers/platform/x86/intel/int3472/tps68470.c b/drivers/platform/x86/intel/int3472/tps68470.c
--- a/drivers/platform/x86/intel/int3472/tps68470.c	2026-01-04 23:41:55.000000000 +0100
+++ b/drivers/platform/x86/intel/int3472/tps68470.c	2026-01-07 11:33:17.876335564 +0100
@@ -17,7 +17,7 @@
 #define DESIGNED_FOR_CHROMEOS		1
 #define DESIGNED_FOR_WINDOWS		2
 
-#define TPS68470_WIN_MFD_CELL_COUNT	3
+#define TPS68470_WIN_MFD_CELL_COUNT	4
 
 static const struct mfd_cell tps68470_cros[] = {
 	{ .name = "tps68470-gpio" },
@@ -46,6 +46,13 @@ static int tps68470_chip_init(struct dev
 		return ret;
 	}
 
+	/* Enable I2C daisy chain */
+	ret = regmap_write(regmap, TPS68470_REG_S_I2C_CTL, 0x03);
+	if (ret) {
+		dev_err(dev, "Failed to enable i2c daisy chain\n");
+		return ret;
+	}
+
 	dev_info(dev, "TPS68470 REVID: 0x%02x\n", version);
 
 	return 0;
@@ -196,7 +203,8 @@ static int skl_int3472_tps68470_probe(st
 		cells[1].name = "tps68470-regulator";
 		cells[1].platform_data = (void *)board_data->tps68470_regulator_pdata;
 		cells[1].pdata_size = sizeof(struct tps68470_regulator_platform_data);
-		cells[2].name = "tps68470-gpio";
+		cells[2].name = "tps68470-led";
+		cells[3].name = "tps68470-gpio";
 
 		for (i = 0; i < board_data->n_gpiod_lookups; i++)
 			gpiod_add_lookup_table(board_data->tps68470_gpio_lookup_tables[i]);
diff -rupN a/include/linux/mfd/tps68470.h b/include/linux/mfd/tps68470.h
--- a/include/linux/mfd/tps68470.h	2026-01-04 23:41:55.000000000 +0100
+++ b/include/linux/mfd/tps68470.h	2026-01-07 11:33:17.876604531 +0100
@@ -34,6 +34,7 @@
 #define TPS68470_REG_SGPO		0x22
 #define TPS68470_REG_GPDI		0x26
 #define TPS68470_REG_GPDO		0x27
+#define TPS68470_REG_ILEDCTL		0x28
 #define TPS68470_REG_VCMVAL		0x3C
 #define TPS68470_REG_VAUX1VAL		0x3D
 #define TPS68470_REG_VAUX2VAL		0x3E
@@ -94,4 +95,8 @@
 #define TPS68470_GPIO_MODE_OUT_CMOS	2
 #define TPS68470_GPIO_MODE_OUT_ODRAIN	3
 
+#define TPS68470_ILEDCTL_ENA		BIT(2)
+#define TPS68470_ILEDCTL_ENB		BIT(6)
+#define TPS68470_ILEDCTL_CTRLB		GENMASK(5, 4)
+
 #endif /* __LINUX_MFD_TPS68470_H */
